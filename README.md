# ARC-кеш (+ Belady-кеш) от студентов 2 курса РТ
## Авторы: Лобачев Артем, Себелев Максим

## Зависимости:
У проекта *нет обязательныз зависимостей*, но для удобной работы могут понадобиться:\
[git](https://git-scm.com/ "ссылка на официальный сайт git")\
[make](https://www.gnu.org/software/make/ "ссылка на оффициальный сайт make") \
[cmake](https://cmake.org/ "ссылка на официальный сайт cmake")\
[g++](https://gcc.gnu.org/ "а у кого нет?")

## Установка:
```bash
git clone https://github.com/Maksim-Sebelev/Cache
```
## Начало работы:
```bash
cd Cache/
mkdir build/
cd build
cmake -S ../Src -DCMAKE_BUILD_TYPE=Release # или =Debug для дебажной версии
```

## Комплиляция:
```bash
make
```

# Тестирование

## запуск тестов:
```bash
make test 
```
или для более подробной информации:
```bash
ctest --verbose
```

# Структура проекта
```txt
.
├── build # рабочая директория (создается Вами)
│   └── <some files created with cmake>
├── .gitignore
├── README.md
├── assets
│   └── weffc++.png
├── project_struct
│   └── project_struct.txt
├── Src
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── cache
│   │   │   ├── arc
│   │   │   │   └── arc_cache.hpp
│   │   │   └── optimal
│   │   │       └── optimal_cache.hpp
│   │   ├── global.hpp
│   │   └── test
│   │       ├── get_test_data.hpp
│   │       ├── input_stream.hpp
│   │       ├── parse_args.hpp
│   │       ├── parse_test_result.hpp
│   │       ├── read_answer.hpp
│   │       ├── read_test.hpp
│   │       └── test_files.hpp
│   └── src
│       └── test
│           ├── arc_cache_test.cpp
│           └── optimal_cache_test.cpp
└── tests
    ├── arc
    │   ├── ans
    │   │   ├── 1.ans
    │   │   ├── 2.ans
    │   │   ├── 3.ans
    │   │   ├── 4.ans
    │   │   ├── 5.ans
    │   │   ├── 6.ans
    │   │   ├── 7.ans
    │   │   └── 8.ans
    │   └── dat
    │       ├── 1.dat
    │       ├── 2.dat
    │       ├── 3.dat
    │       ├── 4.dat
    │       ├── 5.dat
    │       ├── 6.dat
    │       ├── 7.dat
    │       └── 8.dat
    └── optimal
        ├── ans
        │   ├── 1.ans
        │   ├── 2.ans
        │   ├── 3.ans
        │   ├── 4.ans
        │   ├── 5.ans
        │   ├── 6.ans
        │   ├── 7.ans
        │   ├── 8.ans
        │   └── 9.ans
        └── dat
            ├── 1.dat
            ├── 2.dat
            ├── 3.dat
            ├── 4.dat
            ├── 5.dat
            ├── 6.dat
            ├── 7.dat
            ├── 8.dat
            ├── 9.ans
            └── 9.dat

18 directories, 51 files

```
## Объяснение алгоритма ARC (adaptive replacement cache):

[arc cache](https://miro.com/app/board/uXjVJIsDL80=/?focusWidget=3458764640319423359) \
UPD: Грязные капиталюги не дали сделать pdf/хорошего качество фото 

## Как тестируются алгоритмы кеширования?
На вход программа получает размер кеша, количество запросов и сами запросыб. Проверяемым параметром является количество попаданий в кеш (ситуаций, когда вместо долгой подкачки страницы, алгоритм берет ее из быстрого кеша).\
Разберем на примере (мы находимся в папке `build` (см. структуру проекта)):
```bash
./arc_cache_test
5 # размер кеша
8 # количество запросов
1 2 3 4 5 1 2 3 # сами запросы (ровно 8 штук)
```

После чего программа выведет:
```bash
3 # количество попаданий в кеш
```

## Как работает тестирование?
Разберем как прочитать данные из файлов для тестов:
```bash
./arc_cache_test --input_stream=files test.dat test.ans
```
## Важное замечание:
Для тестов программа принимает **исключительно** `.dat` файлы, а для ответов `.ans`

Программа имеет параметр `input_stream`, который принимает 2 значения:
`stdin` и `files`. Первое значение является значением по умолчанию. Это означает, что без явного указания иного, программа ожидает данные с `stdin` и отдает результат в `stdout`. Так же есть краткая форма данной опции `-i`
Таким образом, следующие 3 команды эквивалетны:
```bash
./arc_cache_test
# ожидает данные с stdin
```
```bash
./arc_cache_test --input_stream=stdin
# ожидает данные с stdin
```
```bash
./arc_cache_test -istdin
# ожидает данные с stdin
```

## Как добавить тесты?
Тестирование происходит сразу для двух алгоритмов - arc и belady. \
Вот так на момент написани README.md выглядит структура папки `tests`:
```txt
tests
    ├── arc
    │   ├── ans
    │   │   ├── 1.ans
    │   │   ├── 2.ans
    │   │   ├── 3.ans
    │   │   ├── 4.ans
    │   │   ├── 5.ans
    │   │   ├── 6.ans
    │   │   ├── 7.ans
    │   │   └── 8.ans
    │   └── dat
    │       ├── 1.dat
    │       ├── 2.dat
    │       ├── 3.dat
    │       ├── 4.dat
    │       ├── 5.dat
    │       ├── 6.dat
    │       ├── 7.dat
    │       └── 8.dat
    └── optimal
        ├── ans
        │   ├── 1.ans
        │   ├── 2.ans
        │   ├── 3.ans
        │   ├── 4.ans
        │   ├── 5.ans
        │   ├── 6.ans
        │   ├── 7.ans
        │   ├── 8.ans
        │   └── 9.ans
        └── dat
            ├── 1.dat
            ├── 2.dat
            ├── 3.dat
            ├── 4.dat
            ├── 5.dat
            ├── 6.dat
            ├── 7.dat
            ├── 8.dat
            ├── 9.ans
            └── 9.dat
```
Положим `.` корневой папкой проекта.
Если Вы хотите добавить тесты для `arc cache`, то добавьте в папку `./tests/arc/dat/` файлы с соответсвующим содержимым и названиями `<n>.dat`.
Для каждого вашего теста добавьте в папку `./tests/ans/arc/` соотвествующий файл с тем же названием, что и его тестовый файл `<n>.ans`.\
Аналогично для `optimal cache`.\
После чего выполните
```bash
cmake ../Src -DCMAKE_BUILD_TYPE=Release
make test
```
из папки `./build`. Ваши тесты будут включеные в тестирование и Вы увидете всю необходимую информацию о ваших тестах.

## Почему авторов двое?
В силу ограниченности времени обязанности написания проекта были распределены: Максим писал тестироавание + Cmake, Артем писал алгоритмы кеширования (arc + belady).\
Но это не значит, что каждый делал только свое дело, не разбираясь в деле сокомандника. По итогу каждый получил опыт написания кеша, опыт работы с Cmake и опыт написания тестов (самое сложно было заставить cmake эти тесты делать)

# Проблемы проекта:
## 1
# САМАЯ БОЛЬШАЯ НАША ГЛУПОСТЬ
Мы хотели реализовать более-менее реалистичный кеш, а не просто счетчик потенцальных хитов. И зачем то сделали так:
```C++
using request_t    = typename std::pair<key_t, item_t>;
using input_vector = typename std::vector<request_t>;
```
Но это настолько фундаментально в нашем проекте, что чтобы исправить это означает переделать примерно все алгоритмы кеширования.\
Как мы это пропустили через такое время разработки проекта? - **Я НЕ ИМЕЮ ПОНЯТИЯ :(** я\
Но это не должно влиять (и, кажется, не влияет) на работу алгоритма. Можно даже считать, это некоторым упрощением алгоритма, ведь это позволяет чуть более просто обрабатывать запросы.\
Честно говоря, нам очень стыдно за это (бувально мы реализовали все так, будто пользователь подает на вход и номера страницы, и сами страницы, которые мы по итогу должны ему вернуть), и есть огромное желание это исправить, но нет ни времени, ни сил.


## 2
Мы прекрасно знаем, что Cmake лучше знает какие флаги для релизной и дебажной версии нужны.
О чем говорил Константин Владимиров в своей лекции по системам сборкам.
Но мы не удержались, чтобы насильно не воткнуть так называемые "флаги Деда" (Дед = Дединский Илья Рудольфович), которые служили нам верой и правдой весь 1 курс. И здесь они себя неплохо проявили, показав множество неточностей и неэффективностей в коде.\
Особое внимание заслужил флаг `-Weffc++`. Он единолично заставлял сиять наши экраны от бесконечных warning

![Warning from -Weffc++](./assets/weffc++.png)

поэтому в целях экономии времени и неполного понимания его претензий к коду он был позорно занесен под комментарий (но не удален).

```cmake
set(DEBUG_FLAGS
    -g -D _DEBUG -ggdb3 -O0 -Wall -Wextra -Wcast-align -Wcast-qual -Wchar-subscripts -Wconditionally-supported -Wmissing-declarations -Wformat-security -Wformat-signedness -Wformat=2 -Winline -Wlogical-op -Wnon-virtual-dtor -Wopenmp-simd -Woverloaded-virtual -Wpacked -Wpointer-arith -Wconversion -Wctor-dtor-privacy -Wempty-body -Wfloat-equal -Wformat-nonliteral -fstrict-overflow -flto-odr-type-merging -fno-omit-frame-pointer -Wstack-usage=8192 -Winit-self -Wredundant-decls -Wshadow -Wsign-conversion -Wsign-promo -Wstrict-null-sentinel -Wstrict-overflow=2 -Wsuggest-attribute=noreturn -Wsuggest-final-methods -Wsuggest-final-types -Wsuggest-override -Wswitch-default -Wsync-nand -Wundef -Wunreachable-code -Wunused -Wuseless-cast -Wvariadic-macros -Wno-literal-suffix -Wno-missing-field-initializers -Wno-narrowing -Wno-old-style-cast -Wno-varargs -Wstack-protector -fcheck-new -fsized-deallocation -fstack-protector -pie -fPIE -Werror=vla
    # -Weffc++
)
```
## 3
*(По этому вопросу я подходил к Константину Игоревичу. Мне объяснили, что вероятно код неправильно спроектирован, но эту проблему рассмотрят на дальнейших лекциях)*\
Реализован класс `template <typename input_t> class test_data_t`, который **полностью** отвечает за получение тестовых данных. Данные можно получить 2 спобосами:
со стандартного потока или с файлов (регулируется параметрами командной строки). Но в универсальности класса кроестся проблема:\
у класса есть 2 конструктора: для чтения с stdin и для чтения с файлов. Выбор конструктора зависит от входных данных, поэтому нет просто способа объявить переменную с нужным конструктором.\
**Как проблема решена?**\
Реализована функция
```C++
template <typename input_t>
test_data_t<input_t>* get_test_data(int argc, char* argv[]);
```
которая внутри себя динамически выделяет память под переменную `test_data` и уже потом вызывает конструктор в зависимоти от входных данных. Потому в конце программы можно увидеть строчки:
```C++
delete test_data;
```
Мы пытались сделать просто возврат (не указателя, а непосредстенно самого класса), но это приводило к ошибками, которые мы были не в состоянии осмыслить.\

## 4
Отсуствие связности между кешами (`arc` и `belady`). Это значит что нет общего интерфейса для работы с кешами.\
В свою защиту скажем, что и без общего интерфейса есть неплохая (конечно довольно посредственная, но сделаем `#define посредственная неплохая`) модульность: есть отдельные модули для:\
1) Чтения и обработка входных данных (включая минимальный тест корректности (например нельзя подать отрицательное число как размер кеша) и обработку флагов)
2) Парсинга полученных результатов тестирования кеша (вывод на `stdin` или сравнения с коректным ответом, полученным из `.ans` файла)

    2.5 Cами кеши имеют неплохую модульность и способы работы с входными данными.\

**Почему 2.5, а не 3?**
Нет драйвера для работы с произвольным типом кеша, поэтому `main` для обоих кешей крайни похожи. Но опять же не хватает времени.\
По факту сами `main` для кешей можно было бы рассматривать как функции от кеша, но мы это не реализовали.\

Итого: при неплохой модульности, не реализовано связывание всех модулей во единый модуль, от чего имеем 2 эдентичных `main`.

# Немного рассуждений о clang-format и подобных вещах:
Мое личное мнение (на связи **Максим**) касаемое таких вещей:\
Нет ничего плохого в авто-форматерах кода, но:
1) Они не поддерживают выравненивание определений, вызовов функций (да есть вещи созданные для этого, но как по мне - они странные) и подобных вещей, коих фанатом я являюсь (во много под влиянием Ильи Рудольфовича Дединского)(см. картинку)
![Как я люблю выравнивать код:](./assets/leveling.png)
1) У всех любителей есть свой конфиг. Если любой, кто захочет посмотрет код, может применить свой любимый способ форматирования.

Потому не вижу особого смысла делать принудительное форматирование для проектов.
